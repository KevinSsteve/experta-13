// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://qinlsswojrcuvdudlpvf.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFpbmxzc3dvanJjdXZkdWRscHZmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM4ODI1MTAsImV4cCI6MjA1OTQ1ODUxMH0.PvgmJHdjEbwzzg3Je5nYoLb2uZQeWD2qit6iMJ7UFzM";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Products image functions
export const getProductImageUrl = (imagePath: string) => {
  if (!imagePath || imagePath === '/placeholder.svg') {
    return '/placeholder.svg';
  }
  
  // Check if it's a full URL already (for testing/fallback scenarios)
  if (imagePath.startsWith('http')) {
    return imagePath;
  }
  
  // If path starts with 'products/', assume it's a storage path
  if (imagePath.startsWith('products/')) {
    // Get public URL from storage
    const { data } = supabase.storage.from('products').getPublicUrl(imagePath);
    return data?.publicUrl || '/placeholder.svg';
  }
  
  // Return the path as-is if it doesn't match any of the above conditions
  return imagePath;
};

// User information functions
export const logCurrentUser = async () => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      console.log("Current user:", user.id, user.email);
      return user;
    }
    console.log("No user logged in");
    return null;
  } catch (error) {
    console.error("Error getting current user:", error);
    return null;
  }
};

// Product import functions
export const addMultiplePublicProducts = async (products: any[], userId: string) => {
  try {
    const productsWithUserId = products.map(product => ({
      ...product,
      user_id: userId,
      is_public: true,
      stock: product.stock || 10
    }));
    
    const { data, error } = await supabase
      .from('products')
      .insert(productsWithUserId)
      .select();
      
    if (error) throw error;
    
    console.log(`Successfully added ${data.length} public products`);
    return data;
  } catch (error) {
    console.error("Error adding public products:", error);
    throw error;
  }
};

// Sales data functions for Dashboard and Resultados
export const getSalesReportData = async (
  userId: string,
  startDate: Date,
  endDate: Date
) => {
  try {
    console.log(`Buscando dados de relatório de vendas para usuário ${userId}`);
    console.log(`Período: de ${startDate.toISOString()} até ${endDate.toISOString()}`);
    
    // Verificar se o userId é válido
    if (!userId) {
      console.error('ID de usuário inválido na função getSalesReportData');
      return [];
    }
    
    // Verificar se as datas são válidas
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      console.error('Datas inválidas na função getSalesReportData');
      return [];
    }
    
    // Buscar os dados do Supabase
    console.log('Executando consulta na tabela sales...');
    const { data, error } = await supabase
      .from('sales')
      .select('*')
      .eq('user_id', userId)
      .gte('date', startDate.toISOString())
      .lte('date', endDate.toISOString())
      .order('date', { ascending: true });
    
    if (error) {
      console.error('Erro ao buscar dados de relatório de vendas:', error);
      throw error;
    }
    
    console.log(`Recebidos ${data?.length || 0} registros de vendas`);
    
    // Verificar se o campo user_id está correto nos dados
    if (data && data.length > 0) {
      const firstItem = data[0];
      console.log('Exemplo de registro de venda:', {
        id: firstItem.id,
        user_id: firstItem.user_id,
        date: firstItem.date,
        total: firstItem.total
      });
    }
    
    return data || [];
  } catch (error) {
    console.error('Erro em getSalesReportData:', error);
    throw error;
  }
};

// Function to update or create a financial report
export const updateFinancialReport = async (
  userId: string,
  reportData: {
    title: string;
    description?: string;
    report_type: string;
    period_start: Date;
    period_end: Date;
    total_revenue: number;
    total_cost: number;
    total_profit: number;
    metrics?: any;
  }
) => {
  try {
    // Formatar datas corretamente para PostgreSQL
    const formattedData = {
      ...reportData,
      user_id: userId,
      period_start: reportData.period_start.toISOString().split('T')[0],
      period_end: reportData.period_end.toISOString().split('T')[0],
    };
    
    console.log('Salvando relatório financeiro:', formattedData);
    
    const { data, error } = await supabase
      .from('financial_reports')
      .insert(formattedData)
      .select()
      .single();
    
    if (error) {
      console.error('Erro ao atualizar relatório financeiro:', error);
      throw error;
    }
    
    console.log('Relatório financeiro salvo com sucesso:', data);
    
    // Agora adicione métricas, se fornecidas
    if (reportData.metrics && data.id) {
      for (const [key, value] of Object.entries(reportData.metrics)) {
        // Garantir que o valor é um número para métricas numéricas
        const metricValue = typeof value === 'number' ? value : 0;
        
        const metricData = {
          report_id: data.id,
          metric_name: key,
          metric_type: typeof value === 'number' ? 'numeric' : 'text',
          value: metricValue // Garantir que isso é sempre um número
        };
        
        const { error: metricError } = await supabase
          .from('financial_metrics')
          .insert(metricData);
          
        if (metricError) {
          console.error(`Erro ao salvar métrica ${key}:`, metricError);
        }
      }
    }
    
    return data;
  } catch (error) {
    console.error('Erro em updateFinancialReport:', error);
    throw error;
  }
};

// Function to automatically generate financial reports after sales
export const generateSalesReport = async (userId: string, days: number = 30) => {
  try {
    // Calcular intervalo de datas
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    
    console.log(`Gerando relatório de vendas para usuário ${userId} de ${startDate.toISOString()} até ${endDate.toISOString()}`);
    
    // Obter dados de vendas
    const salesData = await getSalesReportData(userId, startDate, endDate);
    
    if (!salesData || salesData.length === 0) {
      console.log('Nenhum dado de vendas disponível para geração de relatório');
      return null;
    }
    
    console.log(`Encontrados ${salesData.length} registros de vendas para geração de relatório`);
    
    // Calculate financial metrics
    const totalRevenue = salesData.reduce((sum, sale) => sum + Number(sale.total), 0);
    
    // Estimate costs (in a real app, you would have actual cost data)
    // Here we're using a simplified approach with 60% profit margin
    const estimatedCostPercentage = 0.4;
    const totalCost = totalRevenue * estimatedCostPercentage;
    const totalProfit = totalRevenue - totalCost;
    
    console.log('Calculated metrics:', { totalRevenue, totalCost, totalProfit });
    
    // Create report title and description
    const reportTitle = `Relatório de Vendas: ${startDate.toLocaleDateString()} a ${endDate.toLocaleDateString()}`;
    const reportDescription = `Relatório automático de vendas para o período de ${days} dias`;
    
    // Create the report
    const report = await updateFinancialReport(userId, {
      title: reportTitle,
      description: reportDescription,
      report_type: 'sales',
      period_start: startDate,
      period_end: endDate,
      total_revenue: totalRevenue,
      total_cost: totalCost,
      total_profit: totalProfit,
      metrics: {
        total_sales: salesData.length,
        average_sale: salesData.length > 0 ? totalRevenue / salesData.length : 0
      }
    });
    
    return report;
  } catch (error) {
    console.error('Erro ao gerar relatório de vendas:', error);
    return null;
  }
};

// Export other functions that might be needed
